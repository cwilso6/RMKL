% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SurvMKL.R
\name{SurvMKL}
\alias{SurvMKL}
\title{SurvMKL}
\usage{
SurvMKL(K, y, del, rho0, C = 0.5, lambda = 0.5, maxiter = 500, cri = 0.01)
}
\arguments{
\item{K}{The multiple kernel cube (3-d array)}

\item{y}{Vector of survival times}

\item{del}{Indicator vector of whether an event occured (0 = no event, 1 = event occured)}

\item{rho0}{Argmin Dual objective function}

\item{C}{cost parameter is the loss function}

\item{lambda}{tuning parameter for the elastic net. Lambda closer 1 corresponds to L1 and closer to 0 corresponds to L2 penalties.}

\item{maxiter}{maximum number of allowed iteratons for outer loop, default to be 500}

\item{cri}{change between to iterations is smaller than this, algorithms is considered to have converged, default to be .001}
}
\value{
alpha coeffiencents of the dual of SurvMKL
}
\description{
This function conducts SurvMKL for precomputed gramm matrices
}
\examples{
\dontrun{
library(RMKL)
library(kernlab)
data(Surv_data)
#Getting survival times in ascending order
ordtr <- order(Surv_data$time)
Surv_data_ordered = Surv_data[ordtr,]

xx = Surv_data_ordered[,1:2]
del = Surv_data_ordered$status
yy = Surv_data_ordered$time
if (!del[1]) {
  first1 <- which(del)[1]
  xx <- xx[-(1:(first1 - 1)), ]
  yy <- yy[-(1:(first1 - 1))]
  del <- del[-(1:(first1 - 1))]
  nn <- dim(Surv_data)[1] - first1 + 1
} else {
  nn <- dim(Surv_data)[1]
}

rho0 <- .001*(Surv_data$status - seq(0, 10, length.out = dim(Surv_data)[1]))
klist <- list(kernelMatrix(rbfdot(1), as.matrix(xx)),
              kernelMatrix(vanilladot(), as.matrix(xx)))
ktlist <- list(kernelMatrix(rbfdot(1), as.matrix(xx), as.matrix(Surv_data[,1:2])),
               kernelMatrix(vanilladot(), as.matrix(xx), as.matrix(Surv_data[,1:2])))
kk <- simplify2array(klist)
kkk <- simplify2array(ktlist)
modmkl <- SurvMKL(y = Surv_data$time, del = Surv_data$status, K = kk, rho =  
rho0, C = 0.005, lambda = 0.5, maxiter = 500, cri = .01)
}
}
